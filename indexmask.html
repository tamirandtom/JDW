<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js webgl - postprocessing - masking</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            background-color: #000;
            margin: 0px;
            overflow: hidden;
        }
    </style>
</head>

<body>

    <div id="container"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/85/three.min.js"></script>

    <script src="js/postprocessing/min.js"></script>
    <script>
        // if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
        var composer, renderer;
        var box, torus;

        var BoxesNumber = 10;
        var boxArr = [];

        var meshArr = [];
          var meshArr3 = [];
        var meshArr2 = [];
        var rotationsArr = [];
        var maxSize = 50;
        var minSize = 3;
        var boxWidth, boxHeight, boxDepth;
        var camera,scene1,scene2,scene3;


        init();
        animate();

        function createMaterials() {

            var repeatTexture = THREE.ImageUtils.loadTexture('../img/t.jpg');
            repeatTexture.wrapS = repeatTexture.wrapT = THREE.RepeatWrapping;
            // repeatTexture.repeat.set( 3, 3 );
            repeatTexture.depthTest = false;
            repeatTexture.depthWrite = false;
            // var lavaMaterial = new THREE.MeshBasicMaterial( { map: repeatTexture } );
            var materials = [
                // new THREE.MeshBasicMaterial( { color: 0xff0000 } ),
                new THREE.MeshBasicMaterial({
                    map: repeatTexture,
                    overdraw: true
                }),
                new THREE.MeshBasicMaterial({
                    color: 0xffff00
                }),
                new THREE.MeshBasicMaterial({
                    map: repeatTexture,
                    overdraw: true
                }),
                new THREE.MeshBasicMaterial({
                    color: 0x00ffff
                }),
                new THREE.MeshBasicMaterial({
                    map: repeatTexture,
                    overdraw: true
                }),
                new THREE.MeshBasicMaterial({
                    color: 0xff00ff
                })
            ];
            return materials;
        }
           function createMaterials2() {

            var repeatTexture = THREE.ImageUtils.loadTexture('../img/t.jpg');
            repeatTexture.wrapS = repeatTexture.wrapT = THREE.RepeatWrapping;
            // repeatTexture.repeat.set( 3, 3 );
            repeatTexture.depthTest = false;
            repeatTexture.depthWrite = false;
            // var lavaMaterial = new THREE.MeshBasicMaterial( { map: repeatTexture } );
            var materials = [
                // new THREE.MeshBasicMaterial( { color: 0xff0000 } ),
                new THREE.MeshBasicMaterial({
                    map: repeatTexture,
                    overdraw: true
                }),
                new THREE.MeshBasicMaterial({
                    color: 0xffff00
                })
            ];
            return materials;
        }



        function init() {
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.z = -300;
            scene1 = new THREE.Scene();
            scene2 = new THREE.Scene();
            scene3 = new THREE.Scene();

            for (j = 0; j < BoxesNumber; j++) {
                boxWidth = Math.floor((Math.random() * (maxSize - minSize)) + minSize)
                boxHeight = Math.floor((Math.random() * (maxSize - minSize)) + minSize)
                boxDepth = Math.floor((Math.random() * (maxSize - minSize)) + minSize)
                boxArr[j] = new THREE.BoxBufferGeometry(boxWidth, boxHeight, boxDepth);
                meshArr[j] = new THREE.Mesh(boxArr[j], createMaterials());
                meshArr2[j] = new THREE.Mesh(boxArr[j], createMaterials2());

                meshArr[j].position.x = meshArr2[j].position.x = Math.floor((Math.random() * 400) - 200);
                meshArr[j].position.y = meshArr2[j].position.y  = Math.floor((Math.random() * 400) - 200);
                meshArr[j].position.z = meshArr2[j].position.z  = Math.floor((Math.random() * 100) + 100);

                rotationsArr = [Math.random(),Math.random(),Math.random()];

                meshArr[j].rotation.x = rotationsArr[0];
                meshArr[j].rotation.y = rotationsArr[1];
                meshArr[j].rotation.z = rotationsArr[2];
                 meshArr2[j].rotation.x = rotationsArr[0];
                meshArr2[j].rotation.y = rotationsArr[1];
                meshArr2[j].rotation.z = rotationsArr[2];

                scene1.add(meshArr[j]);
                scene2.add(meshArr2[j]);
                //  scene3.add(meshArr2[j]);
            }

            renderer = new THREE.WebGLRenderer({
                antialias: false
            });
            renderer.setClearColor(0xe0e0e0);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.autoClear = false;
            document.body.appendChild(renderer.domElement);
            //
            var clearPass = new THREE.ClearPass();
            var clearMaskPass = new THREE.ClearMaskPass();
            var maskPass1 = new THREE.MaskPass(scene1, camera);
            var maskPass2 = new THREE.MaskPass(scene2, camera);
            // var renderPass = new THREE.RenderPass( scene3, camera );
            var texture1 = new THREE.TextureLoader().load('../img/t.jpg');
            var texture2 = new THREE.TextureLoader().load('../img/t2.jpg');
            var texturePass1 = new THREE.TexturePass(texture1);
            var texturePass2 = new THREE.TexturePass( texture2 );
            var outputPass = new THREE.ShaderPass(THREE.CopyShader);
            outputPass.renderToScreen = true;
            var parameters = {
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                format: THREE.RGBFormat,
                stencilBuffer: true
            };
            var renderTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, parameters);
            composer = new THREE.EffectComposer(renderer, renderTarget);
            composer.addPass(clearPass);
            composer.addPass(maskPass1);
            composer.addPass(texturePass1);
            composer.addPass(clearMaskPass);
            composer.addPass( maskPass2 );
            composer.addPass( texturePass2 );
            composer.addPass(clearMaskPass);
            // composer.addPass(renderPass);
            
            composer.addPass(outputPass);
                document.addEventListener('mousemove', onDocumentMouseMove, false);
    document.addEventListener('mouseover', onDocumentMouseMove, false);
        }

        function animate() {
            requestAnimationFrame(animate);
            var time = performance.now() * 0.001;
    camera.position.x += (mouseX - camera.position.x) * .05;
    camera.position.y += (-mouseY - camera.position.y) * .05;


        for (j = 0; j < BoxesNumber; j++) {

        meshArr[j].rotation.z = meshArr2[j].rotation.z += 0.003;
        meshArr[j].rotation.x = meshArr2[j].rotation.x += 0.002;
        // meshArr[j].rotation.y = Math.floor((Math.random() * 400 ) -200);
        // meshArr[j].position.z = Math.floor((Math.random() * 100 ) +100);
    }


 camera.lookAt(scene1.position);
            renderer.clear();
            composer.render(time);
        }



function onDocumentMouseMove(event) {
    var windowHalfX = window.innerWidth / 2;
    var windowHalfY = window.innerHeight / 2;
    mouseX = (event.clientX - windowHalfX) / 2;
    mouseY = (event.clientY - windowHalfY) / 2;
}



    </script>
</body>